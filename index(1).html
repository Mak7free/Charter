<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cell Rolling - Stable Turntable View</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #050505; }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.95);
            color: white;
            padding: 20px;
            border-radius: 8px;
            width: 340px;
            backdrop-filter: blur(8px);
            border: 1px solid #333;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        h2 { margin-top: 0; font-size: 1.1rem; border-bottom: 1px solid #444; padding-bottom: 10px; color: #f0c040; text-transform: uppercase; letter-spacing: 1px; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-size: 0.85rem; color: #888; text-transform: uppercase; }
        button {
            width: 100%;
            padding: 12px;
            background: #d32f2f;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
            font-size: 0.85rem;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
            border: 1px solid #b71c1c;
        }
        button:hover { background: #b71c1c; box-shadow: 0 0 10px #d32f2f; }
        button.active { background: #2e7d32; border-color: #1b5e20; box-shadow: 0 0 10px #2e7d32; }
        .legend-item { display: flex; align-items: center; margin-bottom: 8px; font-size: 0.8rem; color: #ccc; }
        .dot { width: 8px; height: 8px; border-radius: 50%; margin-right: 10px; flex-shrink: 0; }
        .info { font-size: 0.8rem; color: #aaa; margin-top: 15px; line-height: 1.5; border-top: 1px solid #333; padding-top: 10px; }
        #stats { margin-top: 10px; font-family: 'Courier New', monospace; color: #f0c040; font-size: 0.85rem; }
        .slider-container { display: flex; align-items: center; margin-top: 8px; }
        input[type=range] { flex: 1; margin-left: 10px; cursor: pointer; accent-color: #f0c040; }
        #axis-label {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #00ff00;
            font-family: monospace;
            font-weight: bold;
            pointer-events: none;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="ui-panel">
        <h2>Inverted Microscope View</h2>
        
        <div class="control-group">
            <label>Laser Control</label>
            <button id="toggle-anim-btn" onclick="toggleAnimation()">Activate Laser</button>
            
            <div class="slider-container">
                <label style="margin:0; min-width:70px;">Rotation:</label>
                <input type="range" min="0" max="0.05" step="0.001" value="0.01" id="roll-speed" oninput="updateSpeed()">
            </div>
             <div class="slider-container" style="margin-top:8px;">
                <label style="margin:0; min-width:70px;">Flow:</label>
                <input type="range" min="0" max="2.0" step="0.1" value="1.0" id="flow-speed" oninput="updateSpeed()">
            </div>
        </div>

        <div class="control-group">
            <label>Visualization Key</label>
            <div class="legend-item">
                <div class="dot" style="background: rgba(255, 215, 0, 0.4); border: 1px solid gold;"></div>
                <span>Gold Substrate (Glass)</span>
            </div>
            <div class="legend-item">
                <div class="dot" style="background: rgba(255, 50, 50, 1.0); box-shadow: 0 0 5px red;"></div>
                <span>Laser Beam (Z-Axis Source)</span>
            </div>
            <div class="legend-item">
                <div class="dot" style="background: cyan; opacity: 0.5;"></div>
                <span>Convection Current</span>
            </div>
            <div class="legend-item">
                <div class="dot" style="background: #0088ff;"></div>
                <span>Upper Organelles (Z > 0)</span>
            </div>
            <div class="legend-item">
                <div class="dot" style="background: #ff4444;"></div>
                <span>Lower Organelles (Z < 0)</span>
            </div>
        </div>

        <div class="info">
            <p><strong>Orientation:</strong> The Z-Axis (Vertical) aligns with Light Propagation from the objective lens below.</p>
            <p><strong>Control:</strong> Click & Drag to orbit the view.</p>
        </div>
        <div id="stats">System: Idle</div>
    </div>
    
    <div id="axis-label">â†‘ Z-Axis (Light Propagation)</div>
    <div id="canvas-container"></div>

    <script>
        // --- DATA DEFINITION ---
        const rawData = {
            centers: [
                { x: 0.4955, y: 1.8880, z: -2.1130 },
                { x: 1.4530, y: -4.5535, z: -0.7318 },
                { x: 0.8735, y: 2.2900, z: -1.8457 },
                { x: 4.2345, y: 5.5730, z: 1.4450 },
                { x: 0.9230, y: -1.7975, z: 0.4948 },
                { x: 1.4465, y: 1.9470, z: -1.9415 },
                { x: -7.3545, y: -0.3885, z: 1.5013 },
                { x: 1.7735, y: -3.5050, z: -0.2461 }
            ],
            vectors: [
                { x: -0.638, y: 0.091, z: -0.697 },
                { x: -0.199, y: -0.988, z: -0.112 },
                { x: -0.063, y: 0.999, z: -0.223 },
                { x: 0.099, y: 0.657, z: 0.781 },
                { x: 0.492, y: -0.564, z: 0.707 },
                { x: 0.903, y: 0.489, z: 0.037 },
                { x: -0.801, y: -0.111, z: 0.622 },
                { x: 0.780, y: -0.507, z: -0.405 }
            ],
            baseRadius: 10.4
        };

        const baseSinglePoints = {
            x: [0.37, 4.39, -1.32, -0.20, -3.47, -1.60, 2.80, 3.37, -5.37, -4.25, -2.41],
            y: [6.75, 8.24, -2.10, -3.27, 1.07, 1.25, 3.30, -2.22, -3.99, -2.94, -9.00],
            z: [1.30, 1.49, 1.13, 0.71, -1.09, -0.77, -0.35, 0.53, 1.50, 0.96, 1.46]
        };

        // --- THREE.JS SETUP ---
        let scene, camera, renderer;
        let sphereGroup, stageGroup, laserBeam, convectionGroup;
        let isSimulating = false;
        let animatedParticles = []; 
        let convectionLines = [];
        let rollSpeed = 0.01;
        let flowMultiplier = 1.0;
        let startTime = 0;

        // Camera Orbit State
        let cameraRadius = 60;
        let cameraTheta = Math.PI / 4; // Horizontal angle
        let cameraPhi = Math.PI / 3;   // Vertical angle (from Z axis)
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.FogExp2(0x050505, 0.01);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // CRITICAL: Set Z as UP axis
            camera.up.set(0, 0, 1);
            updateCameraPosition();
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x222222, 1); 
            scene.add(ambientLight);
            
            // Main Light from "Top" (relative to camera view usually, but let's place it logically)
            const spotLight = new THREE.SpotLight(0xffaa00, 2);
            spotLight.position.set(50, 50, 80);
            spotLight.angle = Math.PI / 4;
            scene.add(spotLight);

            const blueBackLight = new THREE.DirectionalLight(0x0044ff, 1);
            blueBackLight.position.set(-50, -50, 20);
            scene.add(blueBackLight);

            // --- 1. ENVIRONMENT (The Stage) ---
            stageGroup = new THREE.Group();
            scene.add(stageGroup);

            // Gold Substrate (The Floor)
            // Z = -12. 
            const floorGeo = new THREE.PlaneGeometry(200, 200);
            const floorMat = new THREE.MeshPhysicalMaterial({ 
                color: 0xFFD700, 
                roughness: 0.2,
                metalness: 0.1, 
                transparent: true,
                opacity: 0.2, 
                side: THREE.DoubleSide,
                transmission: 0.6
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            // In Three.js, PlaneGeometry is created in XY plane.
            // We want it parallel to XY plane at Z = -12.
            // So no rotation needed if Z is UP? 
            // Wait, PlaneGeometry default normal is +Z. So it is ALREADY in XY plane.
            floor.position.z = -12; 
            stageGroup.add(floor);

            // Grid helper
            const grid = new THREE.GridHelper(100, 20, 0x554400, 0x222222);
            // GridHelper creates grid in XZ plane (Y is up).
            // We need grid in XY plane (Z is up).
            grid.rotation.x = Math.PI / 2; 
            grid.position.z = -12.05;
            stageGroup.add(grid);

            // Laser Beam (Cylinder)
            // From Z < -12 to Surface
            const beamGeo = new THREE.CylinderGeometry(0.5, 3, 50, 32, 1, true);
            const beamMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0.0, 
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false 
            });
            laserBeam = new THREE.Mesh(beamGeo, beamMat);
            // Cylinder default aligns with Y. 
            // We want aligns with Z.
            laserBeam.rotation.x = Math.PI / 2;
            laserBeam.position.z = -37; 
            stageGroup.add(laserBeam);

            // Hot Spot
            const spotGeo = new THREE.CircleGeometry(4, 32);
            const spotMat = new THREE.MeshBasicMaterial({ 
                color: 0xff4400, 
                transparent: true, 
                opacity: 0.0,
                blending: THREE.AdditiveBlending 
            });
            const laserSpot = new THREE.Mesh(spotGeo, spotMat);
            // Circle is XY plane by default. perfect.
            laserSpot.position.z = -11.9; 
            stageGroup.add(laserSpot);
            window.laserSpot = laserSpot; // Ref for anim

            // Z-Axis Indicator (Green Arrow)
            const dir = new THREE.Vector3(0, 0, 1);
            const origin = new THREE.Vector3(0, 0, -15);
            const length = 30;
            const hex = 0x00ff00;
            const arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex, 2, 1);
            // Make it look like a "ray"
            arrowHelper.line.material.linewidth = 2;
            arrowHelper.line.material.transparent = true;
            arrowHelper.line.material.opacity = 0.3;
            stageGroup.add(arrowHelper);


            // --- 2. THE CELL ---
            sphereGroup = new THREE.Group();
            scene.add(sphereGroup);

            const R = rawData.baseRadius;
            
            // Membrane
            const membraneGeo = new THREE.SphereGeometry(R, 64, 64);
            const membraneMat = new THREE.MeshPhysicalMaterial({ 
                color: 0x88ccff, transparent: true, opacity: 0.1, 
                roughness: 0.1, metalness: 0.1, transmission: 0.2, thickness: 1.0,
                depthWrite: false
            });
            const cellSphere = new THREE.Mesh(membraneGeo, membraneMat);
            sphereGroup.add(cellSphere);
            
            const wireGeo = new THREE.WireframeGeometry(membraneGeo);
            const wireMat = new THREE.LineBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.05 });
            const wireframe = new THREE.LineSegments(wireGeo, wireMat);
            sphereGroup.add(wireframe);

            // Internal Particles
            rawData.centers.forEach((center, i) => {
                const vector = rawData.vectors[i];
                const velocityMag = Math.sqrt(vector.x*vector.x + vector.y*vector.y + vector.z*vector.z);
                const isStationary = velocityMag < 0.05;
                
                let color;
                if (isStationary) {
                    color = 0x888888;
                } else {
                    const isUpper = center.z >= 0;
                    color = isUpper ? 0x0088ff : 0xff4444;
                }

                const markerGeo = new THREE.SphereGeometry(0.35, 16, 16);
                const markerMat = new THREE.MeshPhongMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
                const marker = new THREE.Mesh(markerGeo, markerMat);
                
                const initialPos = new THREE.Vector3(center.x, center.y, center.z);
                marker.position.copy(initialPos);
                sphereGroup.add(marker);

                const vel = new THREE.Vector3(vector.x, vector.y, vector.z);
                let arrowHelper = null;
                
                if (!isStationary) {
                    const arrowDir = vel.clone().normalize();
                    const length = vel.length() * 2.0; 
                    arrowHelper = new THREE.ArrowHelper(arrowDir, initialPos, length, 0xffffff, 0.5, 0.3);
                    arrowHelper.line.material.transparent = true;
                    arrowHelper.line.material.opacity = 0.8;
                    arrowHelper.cone.material.transparent = true;
                    arrowHelper.cone.material.opacity = 0.8;
                    sphereGroup.add(arrowHelper);
                }

                animatedParticles.push({
                    mesh: marker,
                    arrow: arrowHelper,
                    initialPos: initialPos,
                    velocity: vel,
                    isStationary: isStationary,
                    randomOffset: Math.random() * 2000 
                });
            });

            // Static Noise
            for (let i = 0; i < baseSinglePoints.x.length; i++) {
                const x = baseSinglePoints.x[i];
                const y = baseSinglePoints.y[i];
                const z = baseSinglePoints.z[i];
                const singleMarker = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.5 })
                );
                singleMarker.position.set(x, y, z);
                sphereGroup.add(singleMarker);
            }

            // --- 3. CONVECTION CURRENTS (Toroidal Flow) ---
            convectionGroup = new THREE.Group();
            scene.add(convectionGroup);

            const curveCount = 12;
            for (let i = 0; i < curveCount; i++) {
                const angle = (i / curveCount) * Math.PI * 2;
                const pts = [];
                // Vertical Ovals in Planes rotated around Z
                // For Torus, we rotate around Z (the laser axis)
                // The loops themselves are in the plane of the Laser Axis and Radial line.
                // Flow: Up near Z-axis, Out, Down far away, In.
                
                for(let j=0; j<=20; j++) {
                    const t = (j/20) * Math.PI * 2;
                    // Oval cross section
                    const r_offset = R + 4 + Math.cos(t) * 4; // Radial distance from Z axis
                    const z_val = Math.sin(t) * 8; // Height variation
                    
                    const x = Math.cos(angle) * r_offset;
                    const y = Math.sin(angle) * r_offset;
                    const z = z_val;

                    pts.push(new THREE.Vector3(x, y, z));
                }
                const curve = new THREE.CatmullRomCurve3(pts);
                const tubGeo = new THREE.TubeGeometry(curve, 20, 0.15, 4, true);
                const tubMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.0,
                    blending: THREE.AdditiveBlending 
                });
                const tube = new THREE.Mesh(tubGeo, tubMat);
                convectionGroup.add(tube);
                convectionLines.push({ mesh: tube, speed: 0.002 + Math.random()*0.002, offset: Math.random() });
            }

            animate();
        }

        function updateCameraPosition() {
            // Spherical to Cartesian (Z up)
            // x = r * sin(phi) * cos(theta)
            // y = r * sin(phi) * sin(theta)
            // z = r * cos(phi)
            camera.position.x = cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);
            camera.position.y = cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            camera.position.z = cameraRadius * Math.cos(cameraPhi);
            camera.lookAt(0, 0, 0);
        }

        function updateSpeed() {
            rollSpeed = parseFloat(document.getElementById('roll-speed').value);
            flowMultiplier = parseFloat(document.getElementById('flow-speed').value);
        }

        function toggleAnimation() {
            isSimulating = !isSimulating;
            const btn = document.getElementById('toggle-anim-btn');
            const stats = document.getElementById('stats');
            
            if (isSimulating) {
                btn.innerText = "Deactivate Laser";
                btn.classList.add('active');
                stats.innerText = "System: LASER ON | CONVECTION ACTIVE";
                
                laserBeam.material.opacity = 0.6;
                window.laserSpot.material.opacity = 0.8;
                convectionLines.forEach(l => l.mesh.material.opacity = 0.15);
                
                startTime = Date.now();
            } else {
                btn.innerText = "Activate Laser";
                btn.classList.remove('active');
                stats.innerText = "System: Idle";
                
                laserBeam.material.opacity = 0.0;
                window.laserSpot.material.opacity = 0.0;
                convectionLines.forEach(l => l.mesh.material.opacity = 0.0);
                
                resetParticles();
            }
        }

        function resetParticles() {
            sphereGroup.rotation.set(0, 0, 0);
            animatedParticles.forEach(p => {
                p.mesh.position.copy(p.initialPos);
                if (p.arrow) p.arrow.position.copy(p.initialPos);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isSimulating) {
                // 1. Roll the cell
                // Rolling on ground means rotation axis is parallel to ground (XY)
                // If convection goes "Out" at top and "In" at bottom...
                // Let's say it rolls around X axis.
                sphereGroup.rotation.x -= rollSpeed;
                
                // 2. Animate Convection Lines
                // Rotate the texture/offset, not the group itself, to simulate flow along the tube?
                // Or just rotate the group around the torus axis? 
                // Torus axis is vertical circle.
                // Let's just rotate the convection group around X to look busy.
                // Actually, toroidal flow is internal.
                // Simple trick: Just wobble them or rotate slightly.
                // For visualization, rotating the whole group around Z makes it spin like a top.
                // Rotating around X makes it tumble.
                // Let's rotate around X to match cell roll.
                convectionGroup.rotation.x -= rollSpeed * 1.5;
                
                // 3. Flicker Laser
                laserBeam.material.opacity = 0.5 + Math.random() * 0.2;

                // 4. Internal Particles
                const now = Date.now();
                const loopDuration = 2000; 
                const R = rawData.baseRadius;

                animatedParticles.forEach(p => {
                    if (p.isStationary) return;
                    const time = (now + p.randomOffset) * flowMultiplier;
                    const progress = (time % loopDuration) / loopDuration;
                    const movementScale = 4.0; 
                    const displacement = p.velocity.clone().multiplyScalar(progress * movementScale);
                    const newPos = p.initialPos.clone().add(displacement);
                    
                    const dist = newPos.length();
                    if (dist >= R) {
                        p.mesh.visible = false;
                        if (p.arrow) p.arrow.visible = false;
                    } else {
                        p.mesh.visible = true;
                        if (p.arrow) p.arrow.visible = true;
                        p.mesh.position.copy(newPos);
                        if (p.arrow) {
                            p.arrow.position.copy(newPos);
                            const loopFade = 1.0 - Math.pow(progress, 3);
                            const edgeDist = R - dist;
                            const edgeFade = Math.min(1.0, edgeDist / 1.5);
                            p.arrow.line.material.opacity = Math.min(loopFade, edgeFade);
                            p.arrow.cone.material.opacity = Math.min(loopFade, edgeFade);
                        }
                    }
                });
            }
            
            // NO IDLE ANIMATION - STABLE TURNTABLE

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- MOUSE ORBIT CONTROLS ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        document.addEventListener('mousedown', () => isDragging = true);
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const delta = {
                    x: e.offsetX - previousMousePosition.x,
                    y: e.offsetY - previousMousePosition.y
                };
                
                // Update angles based on drag
                // Drag X -> change Azimuth (Theta) - Rotate around Z
                cameraTheta -= delta.x * 0.01;
                
                // Drag Y -> change Elevation (Phi) - Rotate up/down
                cameraPhi -= delta.y * 0.01;
                
                // Clamp Phi to avoid flipping (stay above/below poles)
                cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));
                
                updateCameraPosition();
            }
            previousMousePosition = { x: e.offsetX, y: e.offsetY };
        });

        init();
    </script>
</body>
</html>
