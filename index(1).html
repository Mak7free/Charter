</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cell Rolling Simulation (Virtual Microscope)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #050505; }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.9);
            color: white;
            padding: 20px;
            border-radius: 8px;
            width: 340px;
            backdrop-filter: blur(8px);
            border: 1px solid #333;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        h2 { margin-top: 0; font-size: 1.1rem; border-bottom: 1px solid #444; padding-bottom: 10px; color: #f0c040; text-transform: uppercase; letter-spacing: 1px; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-size: 0.85rem; color: #888; text-transform: uppercase; }
        button {
            width: 100%;
            padding: 12px;
            background: #d32f2f;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
            font-size: 0.85rem;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
            border: 1px solid #b71c1c;
        }
        button:hover { background: #b71c1c; box-shadow: 0 0 10px #d32f2f; }
        button.active { background: #2e7d32; border-color: #1b5e20; box-shadow: 0 0 10px #2e7d32; }
        .legend-item { display: flex; align-items: center; margin-bottom: 8px; font-size: 0.8rem; color: #ccc; }
        .dot { width: 8px; height: 8px; border-radius: 50%; margin-right: 10px; flex-shrink: 0; }
        .info { font-size: 0.8rem; color: #aaa; margin-top: 15px; line-height: 1.5; border-top: 1px solid #333; padding-top: 10px; }
        #stats { margin-top: 10px; font-family: 'Courier New', monospace; color: #f0c040; font-size: 0.85rem; }
        .slider-container { display: flex; align-items: center; margin-top: 8px; }
        input[type=range] { flex: 1; margin-left: 10px; cursor: pointer; accent-color: #f0c040; }
    </style>
</head>
<body>
       <nav style="background-color: #333; color: white; padding: 10px 0; text-align: center; font-family: Arial, sans-serif; border-bottom: 3px solid #444; margin-bottom: 0;">
     <a href="index.html" style="background: rgba(255,255,255,0.9); border: 2px solid black; padding: 10px 20px; font-family: Arial, sans-serif; font-weight: bold; text-decoration: none; color: black; box-shadow: 2px 2px 5px rgba(0,0,0,0.2);">
    &larr; Back to Old Plot
       </a>
    <a href="index(1).html" style="color: white; text-decoration: none; font-weight: bold; margin: 0 15px; padding: 5px 10px; border: 1px solid #555; border-radius: 4px; background-color: #444;">
        index(1).html
    </a>
    <a href="interactive_plot.html" style="color: white; text-decoration: none; font-weight: bold; margin: 0 15px; padding: 5px 10px; border: 1px solid #28a745; border-radius: 4px; background-color: #1e7e34;">
        Interactive Dashboard
    </a>
</nav>
    <div id="ui-panel">
        <h2>Experimental Setup</h2>
        
        <div class="control-group">
            <label>Laser Control</label>
            <button id="toggle-anim-btn" onclick="toggleAnimation()">Activate Laser</button>
            
            <div class="slider-container">
                <label style="margin:0; min-width:70px;">Convection:</label>
                <input type="range" min="0" max="0.05" step="0.001" value="0.01" id="roll-speed" oninput="updateSpeed()">
            </div>
             <div class="slider-container" style="margin-top:8px;">
                <label style="margin:0; min-width:70px;">Cytoplasm:</label>
                <input type="range" min="0" max="2.0" step="0.1" value="1.0" id="flow-speed" oninput="updateSpeed()">
            </div>
        </div>

        <div class="control-group">
            <label>Visualization Key</label>
            <div class="legend-item">
                <div class="dot" style="background: #FFD700; box-shadow: 0 0 5px #FFD700;"></div>
                <span>Gold Substrate (Heated)</span>
            </div>
            <div class="legend-item">
                <div class="dot" style="background: rgba(255, 50, 50, 0.8);"></div>
                <span>Laser Beam (Heat Source)</span>
            </div>
            <div class="legend-item">
                <div class="dot" style="background: cyan; opacity: 0.5;"></div>
                <span>Convection Current (Flow)</span>
            </div>
            <div class="legend-item">
                <div class="dot" style="background: #0088ff;"></div>
                <span>Upper Organelles (Z > 0)</span>
            </div>
            <div class="legend-item">
                <div class="dot" style="background: #ff4444;"></div>
                <span>Lower Organelles (Z < 0)</span>
            </div>
        </div>

        <div class="info">
            <p><strong>Mechanism:</strong> The Laser heats the Gold surface. Rising heat creates toroidal convection currents, forcing the cell to rotate.</p>
        </div>
        <div id="stats">System: Idle</div>
    </div>
    
    <div id="canvas-container"></div>

    <script>
        // --- DATA DEFINITION ---
        const rawData = {
            centers: [
                { x: 0.4955, y: 1.8880, z: -2.1130 },
                { x: 1.4530, y: -4.5535, z: -0.7318 },
                { x: 0.8735, y: 2.2900, z: -1.8457 },
                { x: 4.2345, y: 5.5730, z: 1.4450 },
                { x: 0.9230, y: -1.7975, z: 0.4948 },
                { x: 1.4465, y: 1.9470, z: -1.9415 },
                { x: -7.3545, y: -0.3885, z: 1.5013 },
                { x: 1.7735, y: -3.5050, z: -0.2461 }
            ],
            vectors: [
                { x: -0.638, y: 0.091, z: -0.697 },
                { x: -0.199, y: -0.988, z: -0.112 },
                { x: -0.063, y: 0.999, z: -0.223 },
                { x: 0.099, y: 0.657, z: 0.781 },
                { x: 0.492, y: -0.564, z: 0.707 },
                { x: 0.903, y: 0.489, z: 0.037 },
                { x: -0.801, y: -0.111, z: 0.622 },
                { x: 0.780, y: -0.507, z: -0.405 }
            ],
            baseRadius: 10.4
        };

        const baseSinglePoints = {
            x: [0.37, 4.39, -1.32, -0.20, -3.47, -1.60, 2.80, 3.37, -5.37, -4.25, -2.41],
            y: [6.75, 8.24, -2.10, -3.27, 1.07, 1.25, 3.30, -2.22, -3.99, -2.94, -9.00],
            z: [1.30, 1.49, 1.13, 0.71, -1.09, -0.77, -0.35, 0.53, 1.50, 0.96, 1.46]
        };

        // --- THREE.JS SETUP ---
        let scene, camera, renderer, sphereGroup, stageGroup, laserBeam, convectionGroup;
        let isSimulating = false;
        let animatedParticles = []; 
        let convectionLines = [];
        let rollSpeed = 0.01;
        let flowMultiplier = 1.0;
        
        function init() {
            scene = new THREE.Scene();
            // Dark environment for laser contrast
            scene.background = new THREE.Color(0x050505);
            // Fog to give depth to the "liquid"
            scene.fog = new THREE.FogExp2(0x050505, 0.015);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Tilted view to show the surface and the cell
            camera.position.set(30, 20, 40); 
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x222222, 1); 
            scene.add(ambientLight);
            
            const spotLight = new THREE.SpotLight(0xffaa00, 2);
            spotLight.position.set(50, 50, 50);
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.5;
            scene.add(spotLight);

            const blueBackLight = new THREE.DirectionalLight(0x0044ff, 1);
            blueBackLight.position.set(-50, 20, -50);
            scene.add(blueBackLight);

            // --- 1. ENVIRONMENT (The Stage) ---
            stageGroup = new THREE.Group();
            scene.add(stageGroup);

            // Gold Substrate (The Floor)
            // Cell R=10.4. Floor at Z = -12 (Behind/Below)
            const floorGeo = new THREE.PlaneGeometry(200, 200);
            const floorMat = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700, // Gold
                roughness: 0.4,
                metalness: 0.8,
                side: THREE.DoubleSide
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            // Rotate to be XY plane behind the cell? 
            // Previous logic: Cell rotates around X. Cell rolls on surface.
            // If camera is looking from Z, surface is at Z = -R.
            floor.position.z = -12; 
            stageGroup.add(floor);

            // Laser Beam (Cylinder)
            // Coming from "behind" the floor (Z < -12) and hitting the spot
            const beamGeo = new THREE.CylinderGeometry(0.5, 4, 30, 32, 1, true);
            const beamMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0.0, // Start invisible
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            laserBeam = new THREE.Mesh(beamGeo, beamMat);
            laserBeam.rotation.x = Math.PI / 2; // Point along Z
            laserBeam.position.z = -27; // Originating from deep Z
            stageGroup.add(laserBeam);

            // Hot Spot on Floor
            const spotGeo = new THREE.CircleGeometry(3, 32);
            const spotMat = new THREE.MeshBasicMaterial({ color: 0xff3300, transparent: true, opacity: 0.0 });
            laserSpot = new THREE.Mesh(spotGeo, spotMat);
            laserSpot.position.z = -11.9; // Just above floor
            stageGroup.add(laserSpot);


            // --- 2. THE CELL ---
            sphereGroup = new THREE.Group();
            scene.add(sphereGroup);

            const R = rawData.baseRadius;
            
            // Membrane
            const membraneGeo = new THREE.SphereGeometry(R, 64, 64);
            const membraneMat = new THREE.MeshPhysicalMaterial({ 
                color: 0x88ccff, transparent: true, opacity: 0.1, 
                roughness: 0.1, metalness: 0.1, transmission: 0.2, thickness: 1.0
            });
            const cellSphere = new THREE.Mesh(membraneGeo, membraneMat);
            sphereGroup.add(cellSphere);
            
            const wireGeo = new THREE.WireframeGeometry(membraneGeo);
            const wireMat = new THREE.LineBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.05 });
            const wireframe = new THREE.LineSegments(wireGeo, wireMat);
            sphereGroup.add(wireframe);

            // Internal Particles
            rawData.centers.forEach((center, i) => {
                const vector = rawData.vectors[i];
                const velocityMag = Math.sqrt(vector.x*vector.x + vector.y*vector.y + vector.z*vector.z);
                const isStationary = velocityMag < 0.05;
                
                let color;
                if (isStationary) {
                    color = 0x888888;
                } else {
                    const isUpper = center.z >= 0;
                    color = isUpper ? 0x0088ff : 0xff4444;
                }

                const markerGeo = new THREE.SphereGeometry(0.35, 16, 16);
                const markerMat = new THREE.MeshPhongMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
                const marker = new THREE.Mesh(markerGeo, markerMat);
                
                const initialPos = new THREE.Vector3(center.x, center.y, center.z);
                marker.position.copy(initialPos);
                sphereGroup.add(marker);

                const vel = new THREE.Vector3(vector.x, vector.y, vector.z);
                let arrowHelper = null;
                
                if (!isStationary) {
                    const arrowDir = vel.clone().normalize();
                    const length = vel.length() * 2.0; 
                    arrowHelper = new THREE.ArrowHelper(arrowDir, initialPos, length, 0xffffff, 0.5, 0.3);
                    arrowHelper.line.material.transparent = true;
                    arrowHelper.line.material.opacity = 0.8;
                    arrowHelper.cone.material.transparent = true;
                    arrowHelper.cone.material.opacity = 0.8;
                    sphereGroup.add(arrowHelper);
                }

                animatedParticles.push({
                    mesh: marker,
                    arrow: arrowHelper,
                    initialPos: initialPos,
                    velocity: vel,
                    isStationary: isStationary,
                    randomOffset: Math.random() * 2000 
                });
            });

            // Static Noise
            for (let i = 0; i < baseSinglePoints.x.length; i++) {
                const x = baseSinglePoints.x[i];
                const y = baseSinglePoints.y[i];
                const z = baseSinglePoints.z[i];
                const singleMarker = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.5 })
                );
                singleMarker.position.set(x, y, z);
                sphereGroup.add(singleMarker);
            }

            // --- 3. CONVECTION CURRENTS (Toroidal Flow) ---
            convectionGroup = new THREE.Group();
            scene.add(convectionGroup);

            // Create curved lines representing the vortex
            const curveCount = 12;
            for (let i = 0; i < curveCount; i++) {
                const angle = (i / curveCount) * Math.PI * 2;
                
                // Elliptical path in YZ plane, rotated around center
                // Actually, toroidal flow around the laser spot (Center)
                // Flow rises in middle, moves out, falls down.
                
                // Let's make simple loops wrapping around the cell
                const pts = [];
                const radiusX = R + 5;
                const radiusY = R + 8;
                
                for(let j=0; j<=20; j++) {
                    const t = (j/20) * Math.PI * 2;
                    // Toroidal winding?
                    // Simple orbit for visualization
                    const cx = Math.cos(angle) * (R + 4);
                    const cy = Math.cos(t) * (R + 8);
                    const cz = Math.sin(t) * (R + 4); // + offset
                    
                    // Actually, let's just make vertical ovals that rotate
                    pts.push(new THREE.Vector3(
                        Math.cos(angle) * (R + 2 + Math.cos(t)*4),
                        Math.sin(t) * (R + 6),
                        Math.sin(angle) * (R + 2 + Math.cos(t)*4)
                    ));
                }
                const curve = new THREE.CatmullRomCurve3(pts);
                const tubGeo = new THREE.TubeGeometry(curve, 20, 0.15, 4, true);
                const tubMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.0,
                    blending: THREE.AdditiveBlending 
                });
                const tube = new THREE.Mesh(tubGeo, tubMat);
                convectionGroup.add(tube);
                convectionLines.push({ mesh: tube, speed: 0.002 + Math.random()*0.002, offset: Math.random() });
            }

            animate();
        }

        function updateSpeed() {
            rollSpeed = parseFloat(document.getElementById('roll-speed').value);
            flowMultiplier = parseFloat(document.getElementById('flow-speed').value);
        }

        function toggleAnimation() {
            isSimulating = !isSimulating;
            const btn = document.getElementById('toggle-anim-btn');
            const stats = document.getElementById('stats');
            
            if (isSimulating) {
                btn.innerText = "Deactivate Laser";
                btn.classList.add('active');
                stats.innerText = "System: LASER ON | CONVECTION ACTIVE";
                
                // Visuals ON
                laserBeam.material.opacity = 0.4;
                laserSpot.material.opacity = 0.6;
                convectionLines.forEach(l => l.mesh.material.opacity = 0.15);
                
                startTime = Date.now();
            } else {
                btn.innerText = "Activate Laser";
                btn.classList.remove('active');
                stats.innerText = "System: Idle";
                
                // Visuals OFF
                laserBeam.material.opacity = 0.0;
                laserSpot.material.opacity = 0.0;
                convectionLines.forEach(l => l.mesh.material.opacity = 0.0);
                
                resetParticles();
            }
        }

        function resetParticles() {
            sphereGroup.rotation.set(0, 0, 0);
            animatedParticles.forEach(p => {
                p.mesh.position.copy(p.initialPos);
                if (p.arrow) p.arrow.position.copy(p.initialPos);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isSimulating) {
                // 1. Roll the cell
                sphereGroup.rotation.x -= rollSpeed;
                
                // 2. Animate Convection Lines (Rotate them to simulate flow)
                convectionGroup.rotation.x -= rollSpeed * 1.5; // Flow is faster than cell
                
                // 3. Flicker Laser
                laserBeam.material.opacity = 0.3 + Math.random() * 0.1;

                // 4. Internal Particles
                const now = Date.now();
                const loopDuration = 2000; 
                const R = rawData.baseRadius;

                animatedParticles.forEach(p => {
                    if (p.isStationary) return;
                    const time = (now + p.randomOffset) * flowMultiplier;
                    const progress = (time % loopDuration) / loopDuration;
                    const movementScale = 4.0; 
                    const displacement = p.velocity.clone().multiplyScalar(progress * movementScale);
                    const newPos = p.initialPos.clone().add(displacement);
                    
                    const dist = newPos.length();
                    if (dist >= R) {
                        p.mesh.visible = false;
                        if (p.arrow) p.arrow.visible = false;
                    } else {
                        p.mesh.visible = true;
                        if (p.arrow) p.arrow.visible = true;
                        p.mesh.position.copy(newPos);
                        if (p.arrow) {
                            p.arrow.position.copy(newPos);
                            const loopFade = 1.0 - Math.pow(progress, 3);
                            const edgeDist = R - dist;
                            const edgeFade = Math.min(1.0, edgeDist / 1.5);
                            p.arrow.line.material.opacity = Math.min(loopFade, edgeFade);
                            p.arrow.cone.material.opacity = Math.min(loopFade, edgeFade);
                        }
                    }
                });
            } else {
                // Idle Rotation (Entire stage)
                // Use Scene rotation for camera orbit effect
                // Actually, let's just rotate the camera pivot slightly
                const time = Date.now() * 0.0005;
                camera.position.x = Math.sin(time) * 30;
                camera.position.y = 20 + Math.cos(time * 0.5) * 5;
                camera.lookAt(0, 0, 0);
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Mouse Drag to Rotate View
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        document.addEventListener('mousedown', () => isDragging = true);
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaMove = {
                    x: e.offsetX - previousMousePosition.x,
                    y: e.offsetY - previousMousePosition.y
                };
                
                // Simple orbit logic
                // Rotate the SCENE/CAMERA relative
                // Ideally use OrbitControls, but manual is fine for this demo
                // We'll rotate the whole scene group except lights?
                // Easiest is to rotate the root objects
                stageGroup.rotation.y += deltaMove.x * 0.005;
                sphereGroup.rotation.y += deltaMove.x * 0.005;
                convectionGroup.rotation.y += deltaMove.x * 0.005;
                
                stageGroup.rotation.x += deltaMove.y * 0.005;
                sphereGroup.rotation.x += deltaMove.y * 0.005;
                convectionGroup.rotation.x += deltaMove.y * 0.005;
            }
            previousMousePosition = { x: e.offsetX, y: e.offsetY };
        });

        init();
    </script>
</body>
</html>
